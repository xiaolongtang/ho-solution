package com.example.h2sync.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.*;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
public class OracleLoaderService {
    private static final Logger log = LoggerFactory.getLogger(OracleLoaderService.class);

    private final JdbcTemplate h2;
    private final DataSource oracleDs;
    private final int threads;
    private final int batchSize;
    private final int maxRetries;
    private final List<String> blacklistEntries;
    private final Set<String> blacklistExact;
    private final List<Pattern> blacklistPatterns;
    private final String oracleSchema;

    @Autowired
    public OracleLoaderService(
            JdbcTemplate h2,
            @Value("${oracle.driver-class:oracle.jdbc.OracleDriver}") String driverClass,
            @Value("${oracle.url}") String url,
            @Value("${oracle.username}") String user,
            @Value("${oracle.password}") String pass,
            @Value("${oracle.schema}") String schema,
            @Value("${loader.threads:4}") int threads,
            @Value("${loader.batchSize:1000}") int batchSize,
            @Value("${loader.maxRetries:3}") int maxRetries,
            @Value("#{'${loader.blacklist:}'.replace('[','').replace(']','')}") String blacklistCsv
    ) {
        this(h2, createOracleDataSource(driverClass, url, user, pass), schema, threads, batchSize, maxRetries, blacklistCsv);
    }

    OracleLoaderService(
            JdbcTemplate h2,
            DataSource oracleDs,
            String schema,
            int threads,
            int batchSize,
            int maxRetries,
            String blacklistCsv
    ) {
        this.h2 = h2;
        this.oracleDs = oracleDs;
        this.threads = threads;
        this.batchSize = batchSize;
        this.maxRetries = maxRetries;
        this.oracleSchema = schema != null ? schema.toUpperCase(Locale.ROOT) : null;

        List<String> tokens = Arrays.stream((blacklistCsv == null ? "" : blacklistCsv).split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(s -> s.toUpperCase(Locale.ROOT))
                .collect(Collectors.toList());

        Set<String> exact = new LinkedHashSet<>();
        List<Pattern> patterns = new ArrayList<>();
        for (String token : tokens) {
            if (hasWildcard(token)) {
                patterns.add(compileGlob(token));
            } else {
                exact.add(token);
            }
        }

        this.blacklistEntries = Collections.unmodifiableList(tokens);
        this.blacklistExact = Collections.unmodifiableSet(exact);
        this.blacklistPatterns = Collections.unmodifiableList(patterns);

        initFailLogTable();
    }

    private static DataSource createOracleDataSource(String driverClass, String url, String user, String pass) {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName(driverClass != null && !driverClass.isBlank() ? driverClass : "oracle.jdbc.OracleDriver");
        ds.setUrl(url);
        ds.setUsername(user);
        ds.setPassword(pass);
        return ds;
    }

    private void initFailLogTable() {
        String create = "CREATE TABLE IF NOT EXISTS ETL_FAIL_LOG (" +
                "ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "OBJECT_TYPE VARCHAR(32) NOT NULL," +
                "OBJECT_NAME VARCHAR(256) NOT NULL," +
                "ATTEMPT_COUNT INT NOT NULL," +
                "LAST_ATTEMPT TIMESTAMP NOT NULL," +
                "ERROR_MESSAGE CLOB," +
                "CONSTRAINT UQ_OBJ UNIQUE (OBJECT_TYPE, OBJECT_NAME)" +
                ")";
        h2.execute(create);
    }

    public void runFullRefresh() {
        log.info("Starting Oracle -> H2 full refresh. threads={}, batchSize={}, schema={}, blacklist={}",
                threads, batchSize, oracleSchema, blacklistEntries);
        long t0 = System.currentTimeMillis();

        ExecutorService pool = Executors.newFixedThreadPool(threads);
        List<Future<?>> futures = new ArrayList<>();

        Set<String> tables;
        Set<String> views;
        List<Map<String, Object>> sequences;
        try (Connection metadataConn = oracleDs.getConnection()) {
            tables = listTables(metadataConn);
            views = listViews(metadataConn);
            sequences = listSequences(metadataConn);
        } catch (SQLException e) {
            log.error("Oracle connection failure", e);
            throw new RuntimeException(e);
        }

        try {
            for (String t : tables) {
                if (isBlacklisted(t)) continue;
                futures.add(pool.submit(() -> retry(() -> copyTable(t), "TABLE", t)));
            }
            for (String v : views) {
                if (isBlacklisted(v)) continue;
                futures.add(pool.submit(() -> retry(() -> copyViewAsTable(v), "VIEW", v)));
            }
            for (Future<?> f : futures) {
                try {
                    f.get();
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for Oracle tasks", ie);
                } catch (ExecutionException ee) {
                    // retry() already recorded the failure and rethrew, so nothing more to do here.
                }
            }
            futures.clear();

            for (Map<String, Object> seq : sequences) {
                String name = (String) seq.get("SEQUENCE_NAME");
                if (isBlacklisted(name)) continue;
                retry(() -> syncSequence(seq), "SEQUENCE", name);
            }
        } finally {
            pool.shutdown();
        }
        long took = System.currentTimeMillis() - t0;
        log.info("Full refresh completed in {} ms", took);
    }

    private boolean isBlacklisted(String name) {
        String n = name.toUpperCase(Locale.ROOT);
        if (blacklistExact.contains(n) || matchesPattern(n)) return true;
        if (oracleSchema != null) {
            String qualified = oracleSchema + "." + n;
            if (blacklistExact.contains(qualified) || matchesPattern(qualified)) return true;
        }
        return false;
    }

    private boolean matchesPattern(String value) {
        for (Pattern pattern : blacklistPatterns) {
            if (pattern.matcher(value).matches()) {
                return true;
            }
        }
        return false;
    }

    private boolean hasWildcard(String token) {
        return token.indexOf('*') >= 0 || token.indexOf('?') >= 0 || token.indexOf('%') >= 0;
    }

    private Pattern compileGlob(String token) {
        StringBuilder regex = new StringBuilder();
        regex.append('^');
        for (int i = 0; i < token.length(); i++) {
            char c = token.charAt(i);
            switch (c) {
                case '*':
                case '%':
                    regex.append(".*");
                    break;
                case '?':
                    regex.append('.');
                    break;
                case '\\':
                case '.':
                case '^':
                case '$':
                case '+':
                case '{':
                case '}':
                case '[':
                case ']':
                case '|':
                case '(': 
                case ')':
                    regex.append('\\').append(c);
                    break;
                default:
                    regex.append(c);
            }
        }
        regex.append('$');
        return Pattern.compile(regex.toString());
    }

    private void retry(Runnable task, String type, String name) {
        int attempt = 0;
        while (true) {
            try {
                attempt++;
                task.run();
                recordSuccess(type, name);
                return;
            } catch (Exception ex) {
                log.warn("Failed to process {} {} on attempt {}: {}", type, name, attempt, ex.toString());
                if (attempt >= maxRetries) {
                    recordFailure(type, name, attempt, ex);
                    throw ex instanceof RuntimeException ? (RuntimeException) ex : new RuntimeException(ex);
                }
                try {
                    Thread.sleep(1000L * attempt * attempt);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private void recordSuccess(String type, String name) {
        String sql = "MERGE INTO ETL_FAIL_LOG (OBJECT_TYPE, OBJECT_NAME, ATTEMPT_COUNT, LAST_ATTEMPT, ERROR_MESSAGE) " +
                "KEY (OBJECT_TYPE, OBJECT_NAME) VALUES (?, ?, 0, CURRENT_TIMESTAMP(), NULL)";
        h2.update(sql, type, name);
    }

    private void recordFailure(String type, String name, int attempt, Exception ex) {
        String sql = "MERGE INTO ETL_FAIL_LOG (OBJECT_TYPE, OBJECT_NAME, ATTEMPT_COUNT, LAST_ATTEMPT, ERROR_MESSAGE) " +
                "KEY (OBJECT_TYPE, OBJECT_NAME) VALUES (?, ?, ?, CURRENT_TIMESTAMP(), ?)";
        h2.update(sql, type, name, attempt, truncate(exToString(ex), 16000));
    }

    private String truncate(String s, int max) {
        if (s == null) return null;
        return s.length() <= max ? s : s.substring(0, max);
    }

    private String exToString(Exception e) {
        StringBuilder sb = new StringBuilder(e.toString()).append("\n");
        for (StackTraceElement el : e.getStackTrace()) {
            sb.append("  at ").append(el.toString()).append("\n");
        }
        return sb.toString();
    }

    private Set<String> listTables(Connection conn) throws SQLException {
        String sql = "SELECT table_name FROM all_tables WHERE owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                Set<String> out = new TreeSet<>();
                while (rs.next()) out.add(rs.getString(1));
                log.info("Found {} tables in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private Set<String> listViews(Connection conn) throws SQLException {
        String sql = "SELECT view_name FROM all_views WHERE owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                Set<String> out = new TreeSet<>();
                while (rs.next()) out.add(rs.getString(1));
                log.info("Found {} views in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private List<Map<String, Object>> listSequences(Connection conn) throws SQLException {
        String sql = "SELECT sequence_name, increment_by, last_number FROM all_sequences WHERE sequence_owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                List<Map<String, Object>> out = new ArrayList<>();
                while (rs.next()) {
                    Map<String, Object> row = new HashMap<>();
                    row.put("SEQUENCE_NAME", rs.getString("SEQUENCE_NAME"));
                    row.put("INCREMENT_BY", rs.getLong("INCREMENT_BY"));
                    row.put("LAST_NUMBER", rs.getBigDecimal("LAST_NUMBER"));
                    out.add(row);
                }
                log.info("Found {} sequences in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private void syncSequence(Map<String, Object> seq) {
        String name = ((String) seq.get("SEQUENCE_NAME")).toUpperCase(Locale.ROOT);
        long increment = ((Number) seq.get("INCREMENT_BY")).longValue();
        java.math.BigDecimal lastNumber = (java.math.BigDecimal) seq.get("LAST_NUMBER");
        String drop = "DROP SEQUENCE IF EXISTS \"" + name + "\"";
        String create = "CREATE SEQUENCE IF NOT EXISTS \"" + name + "\" START WITH " + lastNumber.toPlainString() + " INCREMENT BY " + increment;
        String alter = "ALTER SEQUENCE \"" + name + "\" RESTART WITH " + lastNumber.toPlainString();
        h2.execute(drop);
        h2.execute(create);
        h2.execute(alter);
        log.info("Synced sequence {} startWith={}", name, lastNumber);
    }

    private void copyTable(String table) {
        String src = oracleSchema + "." + table;
        String tgt = "\"" + table + "\"";
        log.info("Copying table {}", src);
        try (Connection oconn = oracleDs.getConnection();
             Statement s = oconn.createStatement();
             ResultSet rs = s.executeQuery("SELECT * FROM " + src + " WHERE 1=0")) {
            log.debug("Prepared metadata for {} using Oracle connection {}", src, oconn);
            createTargetTableFrom(rs.getMetaData(), tgt);
        } catch (SQLException e) {
            throw new RuntimeException("Prepare target table failed for " + src, e);
        }
        bulkInsertFromSelect("SELECT * FROM " + src, tgt);
    }

    private void copyViewAsTable(String view) {
        String src = oracleSchema + "." + view;
        String tgt = "\"VW_" + view + "\"";
        log.info("Materializing view {} into {}", src, tgt);
        try (Connection oconn = oracleDs.getConnection();
             Statement s = oconn.createStatement();
             ResultSet rs = s.executeQuery("SELECT * FROM " + src + " WHERE 1=0")) {
            log.debug("Prepared metadata for view {} using Oracle connection {}", src, oconn);
            createTargetTableFrom(rs.getMetaData(), tgt);
        } catch (SQLException e) {
            throw new RuntimeException("Prepare target table failed for view " + src, e);
        }
        bulkInsertFromSelect("SELECT * FROM " + src, tgt);
    }

    private void createTargetTableFrom(ResultSetMetaData md, String target) throws SQLException {
        String drop = "DROP TABLE IF EXISTS " + target;
        h2.execute(drop);
        StringBuilder ddl = new StringBuilder("CREATE TABLE ").append(target).append(" (");
        for (int i = 1; i <= md.getColumnCount(); i++) {
            if (i > 1) ddl.append(", ");
            String name = md.getColumnName(i);
            int type = md.getColumnType(i);
            int precision = md.getPrecision(i);
            int scale = md.getScale(i);
            ddl.append("\"").append(name).append("\" ").append(mapType(type, precision, scale));
        }
        ddl.append(")");
        h2.execute(ddl.toString());
    }

    private String mapType(int jdbcType, int precision, int scale) {
        switch (jdbcType) {
            case Types.INTEGER:
            case Types.SMALLINT:
            case Types.TINYINT:
                return "INTEGER";
            case Types.BIGINT:
                return "BIGINT";
            case Types.DECIMAL:
            case Types.NUMERIC:
                if (scale == 0 && precision > 0) {
                    if (precision <= 9) return "INTEGER";
                    if (precision <= 18) return "BIGINT";
                }
                int p = Math.min(precision == 0 ? 38 : precision, 38);
                int s;
                if (scale < 0) {
                    s = Math.min(p, 12);
                } else {
                    s = Math.min(scale, 12);
                }
                if (s <= 0 || s > p) {
                    s = Math.min(p, 12);
                }
                return "DECIMAL(" + p + "," + s + ")";
            case Types.FLOAT:
            case Types.REAL:
            case Types.DOUBLE:
                return "DOUBLE";
            case Types.DATE:
            case Types.TIME:
            case Types.TIMESTAMP:
            case Types.TIMESTAMP_WITH_TIMEZONE:
                return "TIMESTAMP";
            case Types.BOOLEAN:
            case Types.BIT:
                return "BOOLEAN";
            case Types.BLOB:
            case Types.BINARY:
            case Types.VARBINARY:
            case Types.LONGVARBINARY:
                return "BLOB";
            case Types.CLOB:
            case Types.NCLOB:
            case Types.LONGVARCHAR:
            case Types.LONGNVARCHAR:
                return "CLOB";
            case Types.NCHAR:
            case Types.NVARCHAR:
            case Types.CHAR:
            case Types.VARCHAR:
            default:
                int len = precision > 0 ? precision : 255;
                len = Math.min(len, 10000);
                return "VARCHAR(" + len + ")";
        }
    }

    private void bulkInsertFromSelect(String selectSql, String target) {
        String countSql = "SELECT COUNT(1) FROM (" + selectSql + ") t";
        long total = 0;
        try (Connection oconn = oracleDs.getConnection()) {
            try (Statement st = oconn.createStatement();
                 ResultSet crs = st.executeQuery(countSql)) {
                if (crs.next()) total = crs.getLong(1);
            } catch (SQLException e) {
                log.warn("Count failed (non-fatal) for {}: {}", selectSql, e.getMessage());
            }

            try (PreparedStatement src = oconn.prepareStatement(selectSql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
                log.debug("Streaming data for target {} using Oracle connection {}", target, oconn);
                src.setFetchSize(Math.max(batchSize, 100));
                try (ResultSet rs = src.executeQuery()) {
                    ResultSetMetaData md = rs.getMetaData();
                    int cols = md.getColumnCount();
                    StringBuilder sb = new StringBuilder("INSERT INTO ").append(target).append(" (");
                    for (int i = 1; i <= cols; i++) {
                        if (i > 1) sb.append(",");
                        sb.append("\"").append(md.getColumnName(i)).append("\"");
                    }
                    sb.append(") VALUES (");
                    for (int i = 1; i <= cols; i++) {
                        if (i > 1) sb.append(",");
                        sb.append("?");
                    }
                    sb.append(")");
                    String insertSql = sb.toString();

                    try (Connection h2conn = Objects.requireNonNull(h2.getDataSource()).getConnection()) {
                        h2conn.setAutoCommit(false);
                        try (PreparedStatement ins = h2conn.prepareStatement(insertSql)) {
                            long n = 0;
                            while (rs.next()) {
                                for (int i = 1; i <= cols; i++) {
                                    Object v = readColumnValue(rs, md, i);
                                    ins.setObject(i, v);
                                }
                                ins.addBatch();
                                n++;
                                if (n % batchSize == 0) {
                                    ins.executeBatch();
                                    h2conn.commit();
                                    if (total > 0) {
                                        log.info("Inserted {} / {} into {}", n, total, target);
                                    } else if (n % (batchSize * 10) == 0) {
                                        log.info("Inserted {} rows into {}", n, target);
                                    }
                                }
                            }
                            ins.executeBatch();
                            h2conn.commit();
                            log.info("Inserted {} rows into {}", n, target);
                        } catch (SQLException ex) {
                            h2conn.rollback();
                            throw ex;
                        } finally {
                            h2conn.setAutoCommit(true);
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Bulk insert failed for target " + target, e);
        }
    }

    private Object readColumnValue(ResultSet rs, ResultSetMetaData md, int index) throws SQLException {
        int jdbcType = md.getColumnType(index);

        if (isBinaryType(jdbcType)) {
            byte[] data = rs.getBytes(index);
            return rs.wasNull() ? null : data;
        }

        if (isClobType(jdbcType)) {
            String text = rs.getString(index);
            return rs.wasNull() ? null : text;
        }

        if (isTemporalType(jdbcType)) {
            try {
                Timestamp ts = rs.getTimestamp(index);
                if (ts != null || rs.wasNull()) {
                    return ts;
                }
            } catch (SQLException ex) {
                log.debug("Oracle timestamp conversion failed for column {} using getTimestamp: {}", index, ex.getMessage());
            }
        }

        Object value = rs.getObject(index);

        if (value instanceof Blob) {
            return blobToBytes((Blob) value);
        }
        if (value instanceof Clob) {
            return clobToString((Clob) value);
        }

        if (isTemporalType(jdbcType)) {
            return toTimestamp(value);
        }
        return maybeConvertTemporal(value);
    }

    private boolean isTemporalType(int jdbcType) {
        return jdbcType == Types.DATE
                || jdbcType == Types.TIME
                || jdbcType == Types.TIMESTAMP
                || jdbcType == Types.TIMESTAMP_WITH_TIMEZONE
                || jdbcType == Types.TIME_WITH_TIMEZONE;
    }

    private boolean isBinaryType(int jdbcType) {
        return jdbcType == Types.BLOB
                || jdbcType == Types.BINARY
                || jdbcType == Types.VARBINARY
                || jdbcType == Types.LONGVARBINARY;
    }

    private boolean isClobType(int jdbcType) {
        return jdbcType == Types.CLOB
                || jdbcType == Types.NCLOB
                || jdbcType == Types.LONGVARCHAR
                || jdbcType == Types.LONGNVARCHAR;
    }

    private Object maybeConvertTemporal(Object value) throws SQLException {
        if (value == null) return null;
        if (value instanceof Timestamp) return value;
        if (value instanceof java.sql.Date || value instanceof java.sql.Time || value instanceof java.util.Date) {
            return toTimestamp(value);
        }
        if (value instanceof LocalDateTime || value instanceof LocalDate
                || value instanceof Instant || value instanceof OffsetDateTime
                || value instanceof ZonedDateTime) {
            return toTimestamp(value);
        }
        String className = value.getClass().getName();
        if (className.startsWith("oracle.sql.")) {
            return toTimestamp(value);
        }
        return value;
    }

    private byte[] blobToBytes(Blob blob) throws SQLException {
        if (blob == null) {
            return null;
        }
        try {
            long length = blob.length();
            if (length > Integer.MAX_VALUE) {
                throw new SQLException("BLOB length exceeds supported size: " + length);
            }
            return blob.getBytes(1, (int) length);
        } finally {
            free(blob);
        }
    }

    private String clobToString(Clob clob) throws SQLException {
        if (clob == null) {
            return null;
        }
        try {
            long length = clob.length();
            if (length > Integer.MAX_VALUE) {
                throw new SQLException("CLOB length exceeds supported size: " + length);
            }
            return clob.getSubString(1, (int) length);
        } finally {
            free(clob);
        }
    }

    private void free(Blob blob) {
        if (blob == null) {
            return;
        }
        try {
            blob.free();
        } catch (AbstractMethodError | SQLException ignored) {
            // Some drivers (or older JDBC versions) do not support free(); ignore such cases.
        }
    }

    private void free(Clob clob) {
        if (clob == null) {
            return;
        }
        try {
            clob.free();
        } catch (AbstractMethodError | SQLException ignored) {
            // Ignore drivers that do not implement free()
        }
    }

    private Object toTimestamp(Object value) throws SQLException {
        if (value == null) return null;
        if (value instanceof Timestamp) return value;
        if (value instanceof java.sql.Date) {
            return new Timestamp(((java.sql.Date) value).getTime());
        }
        if (value instanceof java.sql.Time) {
            return new Timestamp(((java.sql.Time) value).getTime());
        }
        if (value instanceof java.util.Date) {
            return new Timestamp(((java.util.Date) value).getTime());
        }
        if (value instanceof LocalDateTime) {
            return Timestamp.valueOf((LocalDateTime) value);
        }
        if (value instanceof LocalDate) {
            return Timestamp.valueOf(((LocalDate) value).atStartOfDay());
        }
        if (value instanceof Instant) {
            return Timestamp.from((Instant) value);
        }
        if (value instanceof OffsetDateTime) {
            return Timestamp.valueOf(((OffsetDateTime) value).toLocalDateTime());
        }
        if (value instanceof ZonedDateTime) {
            return Timestamp.valueOf(((ZonedDateTime) value).toLocalDateTime());
        }

        String className = value.getClass().getName();
        if (className.startsWith("oracle.sql.")) {
            try {
                Method method = value.getClass().getMethod("timestampValue");
                Object ts = method.invoke(value);
                if (ts instanceof Timestamp) {
                    return ts;
                }
            } catch (NoSuchMethodException ignored) {
                // fall through and try other conversion methods
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new SQLException("Failed to convert Oracle temporal value of type " + className, e);
            }

            try {
                Method method = value.getClass().getMethod("dateValue");
                Object date = method.invoke(value);
                if (date instanceof java.sql.Date) {
                    return new Timestamp(((java.sql.Date) date).getTime());
                }
            } catch (NoSuchMethodException ignored) {
                // fall through
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new SQLException("Failed to convert Oracle temporal value of type " + className, e);
            }

            try {
                Method method = value.getClass().getMethod("timeValue");
                Object time = method.invoke(value);
                if (time instanceof java.sql.Time) {
                    return new Timestamp(((java.sql.Time) time).getTime());
                }
            } catch (NoSuchMethodException ignored) {
                // fall through
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new SQLException("Failed to convert Oracle temporal value of type " + className, e);
            }
        }

        return value;
    }
}
