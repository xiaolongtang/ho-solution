package com.example.h2sync.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;
import java.io.IOException;
import java.io.Reader;
import java.math.BigDecimal;
import java.sql.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public abstract class AbstractOracleLoaderService {
    protected final Logger log = LoggerFactory.getLogger(getClass());

    protected final JdbcTemplate h2;
    protected final DataSource oracleDs;
    protected final int threads;
    protected final int batchSize;
    protected final int maxRetries;
    protected final Set<String> blacklist;
    protected final String oracleSchema;
    private final OracleViewSqlTranslator viewSqlTranslator;
    private final MigrationReportPrinter reportPrinter;
    private static final int H2_MAX_VARCHAR_LENGTH = 1_000_000_000;

    protected AbstractOracleLoaderService(
            JdbcTemplate h2,
            DataSource oracleDs,
            String schema,
            int threads,
            int batchSize,
            int maxRetries,
            String blacklistCsv
    ) {
        this.h2 = h2;
        this.oracleDs = oracleDs;
        this.threads = threads;
        this.batchSize = batchSize;
        this.maxRetries = maxRetries;
        this.oracleSchema = schema != null ? schema.toUpperCase(Locale.ROOT) : null;
        this.viewSqlTranslator = new OracleViewSqlTranslator(this.oracleSchema);
        this.reportPrinter = new MigrationReportPrinter(
                this.log,
                this.h2,
                this.oracleDs,
                this::quoteIdentifier,
                this::isBlacklisted,
                this.oracleSchema
        );

        this.blacklist = Arrays.stream((blacklistCsv == null ? "" : blacklistCsv).split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(s -> s.toUpperCase(Locale.ROOT))
                .collect(Collectors.toSet());

        initFailLogTable();
    }

    protected static DataSource createOracleDataSource(String driverClass, String url, String user, String pass) {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName(driverClass != null && !driverClass.isBlank() ? driverClass : "oracle.jdbc.OracleDriver");
        ds.setUrl(url);
        ds.setUsername(user);
        ds.setPassword(pass);
        return ds;
    }

    protected abstract String getJobName();

    private void initFailLogTable() {
        String create = "CREATE TABLE IF NOT EXISTS ETL_FAIL_LOG (" +
                "ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "OBJECT_TYPE VARCHAR(32) NOT NULL," +
                "OBJECT_NAME VARCHAR(256) NOT NULL," +
                "ATTEMPT_COUNT INT NOT NULL," +
                "LAST_ATTEMPT TIMESTAMP NOT NULL," +
                "ERROR_MESSAGE CLOB," +
                "CONSTRAINT UQ_OBJ UNIQUE (OBJECT_TYPE, OBJECT_NAME)" +
                ")";
        h2.execute(create);
    }

    public void runFullRefresh() {
        String jobName = getJobName();
        log.info("Starting {}. threads={}, batchSize={}, schema={}, blacklist={}",
                jobName, threads, batchSize, oracleSchema, blacklist);
        long t0 = System.currentTimeMillis();

        ExecutorService pool = Executors.newFixedThreadPool(threads);
        List<Future<?>> futures = new ArrayList<>();

        Set<String> tables;
        Set<String> views;
        List<Map<String, Object>> sequences;
        try (Connection metadataConn = oracleDs.getConnection()) {
            tables = listTables(metadataConn);
            views = listViews(metadataConn);
            sequences = listSequences(metadataConn);
        } catch (SQLException e) {
            log.error("Oracle connection failure", e);
            throw new RuntimeException(e);
        }

        try {
            for (String t : tables) {
                if (isBlacklisted(t)) continue;
                futures.add(pool.submit(() -> retry(() -> copyTable(t), "TABLE", t)));
            }
            waitForFutures(futures);

            syncViewsWithDependencyAwareness(views);

            for (Map<String, Object> seq : sequences) {
                String name = (String) seq.get("SEQUENCE_NAME");
                if (isBlacklisted(name)) continue;
                retry(() -> syncSequence(seq), "SEQUENCE", name);
            }
        } finally {
            pool.shutdown();
        }
        long took = System.currentTimeMillis() - t0;
        try {
            reportPrinter.printReport(tables, views, sequences);
        } catch (Exception ex) {
            log.warn("Failed to generate migration report: {}", ex.toString());
            log.debug("Migration report failure", ex);
        }
        log.info("{} completed in {} ms", jobName, took);
    }

    private boolean isBlacklisted(String name) {
        String n = name.toUpperCase(Locale.ROOT);
        if (blacklist.contains(n)) return true;
        if (oracleSchema != null && blacklist.contains(oracleSchema + "." + n)) return true;
        return false;
    }

    private void waitForFutures(List<Future<?>> futures) {
        try {
            for (Future<?> f : futures) {
                try {
                    f.get();
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for Oracle tasks", ie);
                } catch (ExecutionException ee) {
                    // retry() already recorded the failure and rethrew, so nothing more to do here.
                }
            }
        } finally {
            futures.clear();
        }
    }

    private void syncViewsWithDependencyAwareness(Set<String> views) {
        Deque<String> queue = new ArrayDeque<>();
        for (String view : views) {
            if (!isBlacklisted(view)) {
                queue.addLast(view);
            }
        }

        Map<String, Integer> attempts = new HashMap<>();
        Map<String, Integer> deferrals = new HashMap<>();
        int deferralLimit = Math.max(3, maxRetries) * 4;

        while (!queue.isEmpty()) {
            String view = queue.removeFirst();
            int attempt = attempts.merge(view, 1, Integer::sum);
            try {
                copyView(view);
                recordSuccess("VIEW", view);
            } catch (RuntimeException ex) {
                if (shouldDeferViewCreation(ex) && deferrals.merge(view, 1, Integer::sum) <= deferralLimit) {
                    int deferralCount = deferrals.get(view);
                    log.info("Deferring creation of view {} until dependencies are available (attempt {}, deferral {}). Cause: {}",
                            view, attempt, deferralCount, extractMessage(ex));
                    sleepQuietly(500L * Math.min(deferralCount, 6));
                    queue.addLast(view);
                } else {
                    recordFailure("VIEW", view, attempt, ex);
                    log.warn("Giving up on view {} after {} attempts due to error: {}", view, attempt, ex.toString());
                }
            } catch (Exception ex) {
                recordFailure("VIEW", view, attempt, ex);
                log.warn("Giving up on view {} after {} attempts due to error: {}", view, attempt, ex.toString());
            }
        }
    }

    private boolean shouldDeferViewCreation(Throwable ex) {
        Throwable current = ex;
        while (current != null) {
            if (current instanceof SQLException) {
                SQLException sqlEx = (SQLException) current;
                if ("42S02".equalsIgnoreCase(sqlEx.getSQLState())) {
                    return true;
                }
                String message = sqlEx.getMessage();
                if (message != null) {
                    String upper = message.toUpperCase(Locale.ROOT);
                    if (upper.contains("TABLE \"") && upper.contains("NOT FOUND")) {
                        return true;
                    }
                    if (upper.contains("VIEW \"") && upper.contains("NOT FOUND")) {
                        return true;
                    }
                }
            }
            current = current.getCause();
        }
        return false;
    }

    private String extractMessage(Throwable ex) {
        String message = ex.getMessage();
        if (message != null && !message.isBlank()) {
            return truncate(message, 512);
        }
        Throwable cause = ex.getCause();
        return cause == null ? ex.toString() : extractMessage(cause);
    }

    private void sleepQuietly(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
        }
    }

    private void retry(Runnable task, String type, String name) {
        int attempt = 0;
        while (true) {
            try {
                attempt++;
                task.run();
                recordSuccess(type, name);
                return;
            } catch (Exception ex) {
                log.warn("Failed to process {} {} on attempt {}: {}", type, name, attempt, ex.toString());
                if (attempt >= maxRetries) {
                    recordFailure(type, name, attempt, ex);
                    throw ex instanceof RuntimeException ? (RuntimeException) ex : new RuntimeException(ex);
                }
                try {
                    Thread.sleep(1000L * attempt * attempt);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private void recordSuccess(String type, String name) {
        String sql = "MERGE INTO ETL_FAIL_LOG (OBJECT_TYPE, OBJECT_NAME, ATTEMPT_COUNT, LAST_ATTEMPT, ERROR_MESSAGE) " +
                "KEY (OBJECT_TYPE, OBJECT_NAME) VALUES (?, ?, 0, CURRENT_TIMESTAMP(), NULL)";
        h2.update(sql, type, name);
    }

    private void recordFailure(String type, String name, int attempt, Exception ex) {
        String sql = "MERGE INTO ETL_FAIL_LOG (OBJECT_TYPE, OBJECT_NAME, ATTEMPT_COUNT, LAST_ATTEMPT, ERROR_MESSAGE) " +
                "KEY (OBJECT_TYPE, OBJECT_NAME) VALUES (?, ?, ?, CURRENT_TIMESTAMP(), ?)";
        h2.update(sql, type, name, attempt, truncate(exToString(ex), 16000));
    }

    private String truncate(String s, int max) {
        if (s == null) return null;
        return s.length() <= max ? s : s.substring(0, max);
    }

    private String exToString(Exception e) {
        StringBuilder sb = new StringBuilder(e.toString()).append("\n");
        for (StackTraceElement el : e.getStackTrace()) {
            sb.append("  at ").append(el.toString()).append("\n");
        }
        return sb.toString();
    }

    private Set<String> listTables(Connection conn) throws SQLException {
        String sql = "SELECT table_name FROM all_tables WHERE owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                Set<String> out = new TreeSet<>();
                while (rs.next()) out.add(rs.getString(1));
                log.info("Found {} tables in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private Set<String> listViews(Connection conn) throws SQLException {
        String sql = "SELECT view_name FROM all_views WHERE owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                Set<String> out = new TreeSet<>();
                while (rs.next()) out.add(rs.getString(1));
                log.info("Found {} views in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private List<Map<String, Object>> listSequences(Connection conn) throws SQLException {
        String sql = "SELECT sequence_name, increment_by, last_number FROM all_sequences WHERE sequence_owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                List<Map<String, Object>> out = new ArrayList<>();
                while (rs.next()) {
                    Map<String, Object> row = new HashMap<>();
                    row.put("SEQUENCE_NAME", rs.getString("SEQUENCE_NAME"));
                    row.put("INCREMENT_BY", rs.getLong("INCREMENT_BY"));
                    row.put("LAST_NUMBER", rs.getBigDecimal("LAST_NUMBER"));
                    out.add(row);
                }
                log.info("Found {} sequences in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private void syncSequence(Map<String, Object> seq) {
        String name = ((String) seq.get("SEQUENCE_NAME")).toUpperCase(Locale.ROOT);
        long increment = ((Number) seq.get("INCREMENT_BY")).longValue();
        BigDecimal lastNumber = (BigDecimal) seq.get("LAST_NUMBER");
        String drop = "DROP SEQUENCE IF EXISTS \"" + name + "\"";
        String create = "CREATE SEQUENCE IF NOT EXISTS \"" + name + "\" START WITH " + lastNumber.toPlainString() + " INCREMENT BY " + increment;
        String alter = "ALTER SEQUENCE \"" + name + "\" RESTART WITH " + lastNumber.toPlainString();
        h2.execute(drop);
        h2.execute(create);
        h2.execute(alter);
        log.info("Synced sequence {} startWith={}", name, lastNumber);
    }

    protected void copyTable(String table) {
        String src = oracleSchema + "." + table;
        String tgt = "\"" + table + "\"";
        log.info("Copying table {}", src);
        try (Connection oconn = oracleDs.getConnection();
             Statement s = oconn.createStatement();
             ResultSet rs = s.executeQuery("SELECT * FROM " + src + " WHERE 1=0")) {
            log.debug("Prepared metadata for {} using Oracle connection {}", src, oconn);
            List<String> primaryKeys = fetchPrimaryKeys(table, oconn);
            Map<String, Boolean> nonNullableColumns = fetchNonNullableColumns(table, oconn);
            List<List<String>> uniqueConstraints = fetchUniqueConstraints(table, oconn);
            createTargetTableFrom(rs.getMetaData(), tgt, primaryKeys, nonNullableColumns, uniqueConstraints);
        } catch (SQLException e) {
            throw new RuntimeException("Prepare target table failed for " + src, e);
        }
        String selectSql = buildTableSelectSql(src, table);
        bulkInsertFromSelect(selectSql, tgt);
    }

    protected String buildTableSelectSql(String oracleQualifiedTable, String table) {
        return "SELECT * FROM " + oracleQualifiedTable;
    }

    private void copyView(String view) {
        String src = oracleSchema + "." + view;
        String viewName = "\"" + view + "\"";
        log.info("Creating H2 view {} from Oracle view {}", viewName, src);

        String oracleSql = fetchOracleViewDefinition(view);
        String translatedSql = viewSqlTranslator.translate(oracleSql);

        dropLegacyArtifacts(viewName, view);

        List<String> columns = ensureUniqueColumnNames(view, fetchOracleViewColumns(view));
        String columnList = columns.isEmpty()
                ? ""
                : columns.stream()
                .map(this::quoteIdentifier)
                .collect(Collectors.joining(", ", " (", ")"));

        String createViewSql = "CREATE VIEW " + viewName + columnList + " AS " + translatedSql;
        h2.execute(createViewSql);
        log.info("Created H2 view {} using translated Oracle SQL", viewName);
    }

    private List<String> fetchOracleViewColumns(String view) {
        if (oracleSchema == null || oracleSchema.isBlank()) {
            return Collections.emptyList();
        }

        String sql = "SELECT column_name FROM all_tab_columns WHERE owner = ? AND table_name = ? ORDER BY column_id";
        try (Connection conn = oracleDs.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            ps.setString(2, view);
            try (ResultSet rs = ps.executeQuery()) {
                List<String> columns = new ArrayList<>();
                while (rs.next()) {
                    String column = rs.getString(1);
                    if (column != null && !column.isBlank()) {
                        columns.add(column);
                    }
                }
                if (columns.isEmpty()) {
                    log.warn("No columns found for Oracle view {}. Falling back to default column names", view);
                }
                return columns;
            }
        } catch (SQLException e) {
            log.warn("Failed to fetch column metadata for Oracle view {}. Proceeding without explicit column list", view, e);
            return Collections.emptyList();
        }
    }

    private List<String> ensureUniqueColumnNames(String view, List<String> columns) {
        if (columns.isEmpty()) {
            return columns;
        }

        List<String> unique = new ArrayList<>(columns.size());
        Map<String, Integer> suffixes = new HashMap<>();
        Set<String> used = new HashSet<>();
        boolean renamed = false;

        for (String original : columns) {
            if (original == null) {
                continue;
            }
            String base = original.trim();
            if (base.isEmpty()) {
                continue;
            }

            String candidate = base;
            String normalizedCandidate = candidate.toUpperCase(Locale.ROOT);
            int suffix = suffixes.getOrDefault(base.toUpperCase(Locale.ROOT), 0);

            while (!used.add(normalizedCandidate)) {
                renamed = true;
                suffix++;
                candidate = base + "_" + suffix;
                normalizedCandidate = candidate.toUpperCase(Locale.ROOT);
            }

            suffixes.put(base.toUpperCase(Locale.ROOT), suffix);
            unique.add(candidate);
        }

        if (renamed) {
            log.warn("Oracle view {} contains duplicate column names. Renamed columns for H2 as {}", view, unique);
        }

        return unique;
    }

    private String quoteIdentifier(String identifier) {
        if (identifier == null) {
            throw new IllegalArgumentException("Identifier is null");
        }
        String trimmed = identifier.trim();
        if (trimmed.isEmpty()) {
            throw new IllegalArgumentException("Identifier is blank");
        }
        return "\"" + trimmed.replace("\"", "\"\"") + "\"";
    }

    private void dropLegacyArtifacts(String viewName, String view) {
        h2.execute("DROP VIEW IF EXISTS " + viewName);
        try {
            h2.execute("DROP TABLE IF EXISTS " + viewName + " CASCADE");
        } catch (RuntimeException ex) {
            log.debug("Ignoring failure while dropping legacy table {}: {}", viewName, ex.getMessage());
        }
        String legacyMaterialized = "\"VW_" + view + "\"";
        try {
            h2.execute("DROP TABLE IF EXISTS " + legacyMaterialized + " CASCADE");
        } catch (RuntimeException ex) {
            log.debug("Ignoring failure while dropping legacy materialized table {}: {}", legacyMaterialized, ex.getMessage());
        }
        String legacy = "\"MV\".\"" + view + "\"";
        try {
            h2.execute("DROP TABLE IF EXISTS " + legacy + " CASCADE");
        } catch (RuntimeException ex) {
            log.debug("Ignoring failure while dropping legacy MV table {}: {}", legacy, ex.getMessage());
        }
    }

    private String fetchOracleViewDefinition(String view) {
        try (Connection conn = oracleDs.getConnection()) {
            String definition = fetchViewTextFromAllViews(conn, view);
            if (definition != null && !definition.isBlank()) {
                return definition;
            }
            return fetchViewTextFromMetadata(conn, view);
        } catch (SQLException e) {
            throw new RuntimeException("Failed to fetch Oracle view definition for " + view, e);
        }
    }

    private String fetchViewTextFromAllViews(Connection conn, String view) throws SQLException {
        String sql = "SELECT TEXT FROM all_views WHERE owner = ? AND view_name = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            ps.setString(2, view);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    return null;
                }
                return readLargeText(rs, 1);
            }
        }
    }

    private String fetchViewTextFromMetadata(Connection conn, String view) throws SQLException {
        log.debug("Falling back to DBMS_METADATA for Oracle view {}", view);
        try (Statement st = conn.createStatement()) {
            st.execute("BEGIN DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'SQLTERMINATOR',FALSE); END;");
        } catch (SQLException ex) {
            log.debug("Failed to configure DBMS_METADATA session transform: {}", ex.getMessage());
        }
        String sql = "SELECT dbms_metadata.get_ddl('VIEW', ?, ?) FROM dual";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, view);
            ps.setString(2, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    String ddl = readLargeText(rs, 1);
                    if (ddl != null) {
                        String select = extractSelectFromDdl(ddl);
                        if (select != null && !select.isBlank()) {
                            return select;
                        }
                    }
                }
            }
        }
        throw new SQLException("Unable to retrieve definition for view " + view);
    }

    private String extractSelectFromDdl(String ddl) {
        if (ddl == null) {
            return null;
        }
        Matcher matcher = Pattern.compile("(?i)\\bAS\\b").matcher(ddl);
        if (matcher.find()) {
            return ddl.substring(matcher.end()).trim();
        }
        return null;
    }

    private String readLargeText(ResultSet rs, int index) throws SQLException {
        String text = rs.getString(index);
        if (text != null) {
            return text;
        }
        try (Reader reader = rs.getCharacterStream(index)) {
            if (reader == null) {
                return null;
            }
            StringBuilder sb = new StringBuilder();
            char[] buf = new char[4096];
            int len;
            while ((len = reader.read(buf)) != -1) {
                sb.append(buf, 0, len);
            }
            return sb.toString();
        } catch (IOException ex) {
            throw new SQLException("Failed to read Oracle text column", ex);
        }
    }

    private void createTargetTableFrom(
            ResultSetMetaData md,
            String target,
            List<String> primaryKeys,
            Map<String, Boolean> nonNullableColumns,
            List<List<String>> uniqueConstraints
    ) throws SQLException {
        String drop = "DROP TABLE IF EXISTS " + target + " CASCADE";
        h2.execute(drop);
        StringBuilder ddl = new StringBuilder("CREATE TABLE ").append(target).append(" (");
        for (int i = 1; i <= md.getColumnCount(); i++) {
            if (i > 1) ddl.append(", ");
            String name = md.getColumnName(i);
            int type = md.getColumnType(i);
            int precision = md.getPrecision(i);
            int scale = md.getScale(i);
            int displaySize = md.getColumnDisplaySize(i);
            boolean notNull = Boolean.TRUE.equals(nonNullableColumns.get(name))
                    || md.isNullable(i) == ResultSetMetaData.columnNoNulls
                    || (primaryKeys != null && primaryKeys.contains(name));
            ddl.append("\"").append(name).append("\" ").append(mapType(type, precision, scale, displaySize));
            if (notNull) {
                ddl.append(" NOT NULL");
            }
        }
        if (primaryKeys != null && !primaryKeys.isEmpty()) {
            ddl.append(", PRIMARY KEY (");
            ddl.append(primaryKeys.stream()
                    .map(this::quoteIdentifier)
                    .collect(Collectors.joining(", ")));
            ddl.append(")");
        }
        if (uniqueConstraints != null && !uniqueConstraints.isEmpty()) {
            for (List<String> unique : uniqueConstraints) {
                if (unique.isEmpty()) continue;
                ddl.append(", UNIQUE (");
                ddl.append(unique.stream()
                        .map(this::quoteIdentifier)
                        .collect(Collectors.joining(", ")));
                ddl.append(")");
            }
        }
        ddl.append(")");
        h2.execute(ddl.toString());
    }

    private List<String> fetchPrimaryKeys(String table, Connection oracleConnection) throws SQLException {
        String sql = "SELECT cols.column_name " +
                "FROM all_constraints cons " +
                "JOIN all_cons_columns cols ON cons.owner = cols.owner AND cons.constraint_name = cols.constraint_name " +
                "AND cons.table_name = cols.table_name " +
                "WHERE cons.constraint_type = 'P' AND cons.owner = ? AND cons.table_name = ? " +
                "ORDER BY cols.position";
        try (PreparedStatement ps = oracleConnection.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            ps.setString(2, table);
            try (ResultSet rs = ps.executeQuery()) {
                List<String> columns = new ArrayList<>();
                while (rs.next()) {
                    columns.add(rs.getString("COLUMN_NAME"));
                }
                return columns;
            }
        }
    }

    private Map<String, Boolean> fetchNonNullableColumns(String table, Connection oracleConnection) throws SQLException {
        if (oracleSchema == null || oracleSchema.isBlank()) {
            return Collections.emptyMap();
        }

        String sql = "SELECT column_name, nullable FROM all_tab_columns WHERE owner = ? AND table_name = ?";
        try (PreparedStatement ps = oracleConnection.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            ps.setString(2, table);
            try (ResultSet rs = ps.executeQuery()) {
                Map<String, Boolean> nullable = new HashMap<>();
                while (rs.next()) {
                    String column = rs.getString("COLUMN_NAME");
                    String nullableFlag = rs.getString("NULLABLE");
                    if (column != null) {
                        nullable.put(column, "N".equalsIgnoreCase(nullableFlag));
                    }
                }
                return nullable;
            }
        }
    }

    private List<List<String>> fetchUniqueConstraints(String table, Connection oracleConnection) throws SQLException {
        if (oracleSchema == null || oracleSchema.isBlank()) {
            return Collections.emptyList();
        }

        String sql = "SELECT cons.constraint_name, cols.column_name, cols.position " +
                "FROM all_constraints cons " +
                "JOIN all_cons_columns cols ON cons.owner = cols.owner AND cons.constraint_name = cols.constraint_name " +
                "AND cons.table_name = cols.table_name " +
                "WHERE cons.constraint_type = 'U' AND cons.owner = ? AND cons.table_name = ? " +
                "ORDER BY cons.constraint_name, cols.position";

        Map<String, List<String>> constraints = new LinkedHashMap<>();
        try (PreparedStatement ps = oracleConnection.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            ps.setString(2, table);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    String constraintName = rs.getString("CONSTRAINT_NAME");
                    String column = rs.getString("COLUMN_NAME");
                    if (constraintName == null || column == null) {
                        continue;
                    }
                    constraints.computeIfAbsent(constraintName, k -> new ArrayList<>()).add(column);
                }
            }
        }
        return new ArrayList<>(constraints.values());
    }

    private String mapType(int jdbcType, int precision, int scale, int displaySize) {
        int effectivePrecision = precision > 0 ? precision : displaySize;
        switch (jdbcType) {
            case Types.INTEGER:
            case Types.SMALLINT:
            case Types.TINYINT:
                return "INTEGER";
            case Types.BIGINT:
                return "BIGINT";
            case Types.DECIMAL:
            case Types.NUMERIC:
                if (scale == 0 && precision > 0) {
                    if (precision <= 9) return "INTEGER";
                    if (precision <= 18) return "BIGINT";
                }
                int p = Math.min(precision == 0 ? 38 : precision, 38);
                int s;
                if (scale < 0) {
                    s = Math.min(p, 12);
                } else {
                    s = Math.min(scale, 12);
                }
                if (s < 0 || s > p) {
                    s = Math.min(p, 12);
                }
                return "DECIMAL(" + p + "," + s + ")";
            case Types.FLOAT:
            case Types.REAL:
            case Types.DOUBLE:
                return "DOUBLE";
            case Types.DATE:
            case Types.TIME:
            case Types.TIMESTAMP:
            case Types.TIMESTAMP_WITH_TIMEZONE:
                return "TIMESTAMP";
            case Types.BOOLEAN:
            case Types.BIT:
                return "BOOLEAN";
            case Types.BLOB:
            case Types.BINARY:
            case Types.VARBINARY:
            case Types.LONGVARBINARY:
                return "BLOB";
            case Types.CLOB:
            case Types.NCLOB:
            case Types.LONGVARCHAR:
            case Types.LONGNVARCHAR:
                return "CLOB";
            case Types.NCHAR:
            case Types.NVARCHAR:
            case Types.CHAR:
            case Types.VARCHAR:
            default:
                int len = effectivePrecision > 0 ? effectivePrecision : 255;
                len = Math.min(len, H2_MAX_VARCHAR_LENGTH);
                return "VARCHAR(" + len + ")";
        }
    }

    private void bulkInsertFromSelect(String selectSql, String target) {
        String countSql = "SELECT COUNT(1) FROM (" + selectSql + ") t";
        long total = 0;
        try (Connection oconn = oracleDs.getConnection()) {
            try (Statement st = oconn.createStatement();
                 ResultSet crs = st.executeQuery(countSql)) {
                if (crs.next()) total = crs.getLong(1);
            } catch (SQLException e) {
                log.warn("Count failed (non-fatal) for {}: {}", selectSql, e.getMessage());
            }

            try (PreparedStatement src = oconn.prepareStatement(selectSql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
                log.debug("Streaming data for target {} using Oracle connection {}", target, oconn);
                src.setFetchSize(Math.max(batchSize, 100));
                try (ResultSet rs = src.executeQuery()) {
                    ResultSetMetaData md = rs.getMetaData();
                    int cols = md.getColumnCount();
                    StringBuilder sb = new StringBuilder("INSERT INTO ").append(target).append(" (");
                    for (int i = 1; i <= cols; i++) {
                        if (i > 1) sb.append(",");
                        sb.append("\"").append(md.getColumnName(i)).append("\"");
                    }
                    sb.append(") VALUES (");
                    for (int i = 1; i <= cols; i++) {
                        if (i > 1) sb.append(",");
                        sb.append("?");
                    }
                    sb.append(")");
                    String insertSql = sb.toString();

                    try (Connection h2conn = Objects.requireNonNull(h2.getDataSource()).getConnection()) {
                        h2conn.setAutoCommit(false);
                        try (PreparedStatement ins = h2conn.prepareStatement(insertSql)) {
                            long n = 0;
                            while (rs.next()) {
                                for (int i = 1; i <= cols; i++) {
                                    Object v = OracleJdbcValueConverter.readColumnValue(rs, md, i, log);
                                    ins.setObject(i, v);
                                }
                                ins.addBatch();
                                n++;
                                if (n % batchSize == 0) {
                                    ins.executeBatch();
                                    h2conn.commit();
                                    if (total > 0) {
                                        log.info("Inserted {} / {} into {}", n, total, target);
                                    } else if (n % (batchSize * 10) == 0) {
                                        log.info("Inserted {} rows into {}", n, target);
                                    }
                                }
                            }
                            ins.executeBatch();
                            h2conn.commit();
                            log.info("Inserted {} rows into {}", n, target);
                        } catch (SQLException ex) {
                            h2conn.rollback();
                            throw ex;
                        } finally {
                            h2conn.setAutoCommit(true);
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Bulk insert failed for target " + target, e);
        }
    }

}
