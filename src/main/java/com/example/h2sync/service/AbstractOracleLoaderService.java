package com.example.h2sync.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;
import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.*;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public abstract class AbstractOracleLoaderService {
    protected final Logger log = LoggerFactory.getLogger(getClass());

    protected final JdbcTemplate h2;
    protected final DataSource oracleDs;
    protected final int threads;
    protected final int batchSize;
    protected final int maxRetries;
    protected final Set<String> blacklist;
    protected final String oracleSchema;

    protected AbstractOracleLoaderService(
            JdbcTemplate h2,
            DataSource oracleDs,
            String schema,
            int threads,
            int batchSize,
            int maxRetries,
            String blacklistCsv
    ) {
        this.h2 = h2;
        this.oracleDs = oracleDs;
        this.threads = threads;
        this.batchSize = batchSize;
        this.maxRetries = maxRetries;
        this.oracleSchema = schema != null ? schema.toUpperCase(Locale.ROOT) : null;

        this.blacklist = Arrays.stream((blacklistCsv == null ? "" : blacklistCsv).split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(s -> s.toUpperCase(Locale.ROOT))
                .collect(Collectors.toSet());

        initFailLogTable();
    }

    protected static DataSource createOracleDataSource(String driverClass, String url, String user, String pass) {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName(driverClass != null && !driverClass.isBlank() ? driverClass : "oracle.jdbc.OracleDriver");
        ds.setUrl(url);
        ds.setUsername(user);
        ds.setPassword(pass);
        return ds;
    }

    protected abstract String getJobName();

    private void initFailLogTable() {
        String create = "CREATE TABLE IF NOT EXISTS ETL_FAIL_LOG (" +
                "ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "OBJECT_TYPE VARCHAR(32) NOT NULL," +
                "OBJECT_NAME VARCHAR(256) NOT NULL," +
                "ATTEMPT_COUNT INT NOT NULL," +
                "LAST_ATTEMPT TIMESTAMP NOT NULL," +
                "ERROR_MESSAGE CLOB," +
                "CONSTRAINT UQ_OBJ UNIQUE (OBJECT_TYPE, OBJECT_NAME)" +
                ")";
        h2.execute(create);
    }

    public void runFullRefresh() {
        String jobName = getJobName();
        log.info("Starting {}. threads={}, batchSize={}, schema={}, blacklist={}",
                jobName, threads, batchSize, oracleSchema, blacklist);
        long t0 = System.currentTimeMillis();

        ExecutorService pool = Executors.newFixedThreadPool(threads);
        List<Future<?>> futures = new ArrayList<>();

        Set<String> tables;
        Set<String> views;
        List<Map<String, Object>> sequences;
        try (Connection metadataConn = oracleDs.getConnection()) {
            tables = listTables(metadataConn);
            views = listViews(metadataConn);
            sequences = listSequences(metadataConn);
        } catch (SQLException e) {
            log.error("Oracle connection failure", e);
            throw new RuntimeException(e);
        }

        try {
            for (String t : tables) {
                if (isBlacklisted(t)) continue;
                futures.add(pool.submit(() -> retry(() -> copyTable(t), "TABLE", t)));
            }
            for (String v : views) {
                if (isBlacklisted(v)) continue;
                futures.add(pool.submit(() -> retry(() -> copyView(v), "VIEW", v)));
            }
            for (Future<?> f : futures) {
                try {
                    f.get();
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Interrupted while waiting for Oracle tasks", ie);
                } catch (ExecutionException ee) {
                    // retry() already recorded the failure and rethrew, so nothing more to do here.
                }
            }
            futures.clear();

            for (Map<String, Object> seq : sequences) {
                String name = (String) seq.get("SEQUENCE_NAME");
                if (isBlacklisted(name)) continue;
                retry(() -> syncSequence(seq), "SEQUENCE", name);
            }
        } finally {
            pool.shutdown();
        }
        long took = System.currentTimeMillis() - t0;
        log.info("{} completed in {} ms", jobName, took);
    }

    private boolean isBlacklisted(String name) {
        String n = name.toUpperCase(Locale.ROOT);
        if (blacklist.contains(n)) return true;
        if (oracleSchema != null && blacklist.contains(oracleSchema + "." + n)) return true;
        return false;
    }

    private void retry(Runnable task, String type, String name) {
        int attempt = 0;
        while (true) {
            try {
                attempt++;
                task.run();
                recordSuccess(type, name);
                return;
            } catch (Exception ex) {
                log.warn("Failed to process {} {} on attempt {}: {}", type, name, attempt, ex.toString());
                if (attempt >= maxRetries) {
                    recordFailure(type, name, attempt, ex);
                    throw ex instanceof RuntimeException ? (RuntimeException) ex : new RuntimeException(ex);
                }
                try {
                    Thread.sleep(1000L * attempt * attempt);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private void recordSuccess(String type, String name) {
        String sql = "MERGE INTO ETL_FAIL_LOG (OBJECT_TYPE, OBJECT_NAME, ATTEMPT_COUNT, LAST_ATTEMPT, ERROR_MESSAGE) " +
                "KEY (OBJECT_TYPE, OBJECT_NAME) VALUES (?, ?, 0, CURRENT_TIMESTAMP(), NULL)";
        h2.update(sql, type, name);
    }

    private void recordFailure(String type, String name, int attempt, Exception ex) {
        String sql = "MERGE INTO ETL_FAIL_LOG (OBJECT_TYPE, OBJECT_NAME, ATTEMPT_COUNT, LAST_ATTEMPT, ERROR_MESSAGE) " +
                "KEY (OBJECT_TYPE, OBJECT_NAME) VALUES (?, ?, ?, CURRENT_TIMESTAMP(), ?)";
        h2.update(sql, type, name, attempt, truncate(exToString(ex), 16000));
    }

    private String truncate(String s, int max) {
        if (s == null) return null;
        return s.length() <= max ? s : s.substring(0, max);
    }

    private String exToString(Exception e) {
        StringBuilder sb = new StringBuilder(e.toString()).append("\n");
        for (StackTraceElement el : e.getStackTrace()) {
            sb.append("  at ").append(el.toString()).append("\n");
        }
        return sb.toString();
    }

    private Set<String> listTables(Connection conn) throws SQLException {
        String sql = "SELECT table_name FROM all_tables WHERE owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                Set<String> out = new TreeSet<>();
                while (rs.next()) out.add(rs.getString(1));
                log.info("Found {} tables in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private Set<String> listViews(Connection conn) throws SQLException {
        String sql = "SELECT view_name FROM all_views WHERE owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                Set<String> out = new TreeSet<>();
                while (rs.next()) out.add(rs.getString(1));
                log.info("Found {} views in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private List<Map<String, Object>> listSequences(Connection conn) throws SQLException {
        String sql = "SELECT sequence_name, increment_by, last_number FROM all_sequences WHERE sequence_owner = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                List<Map<String, Object>> out = new ArrayList<>();
                while (rs.next()) {
                    Map<String, Object> row = new HashMap<>();
                    row.put("SEQUENCE_NAME", rs.getString("SEQUENCE_NAME"));
                    row.put("INCREMENT_BY", rs.getLong("INCREMENT_BY"));
                    row.put("LAST_NUMBER", rs.getBigDecimal("LAST_NUMBER"));
                    out.add(row);
                }
                log.info("Found {} sequences in Oracle schema {}", out.size(), oracleSchema);
                return out;
            }
        }
    }

    private void syncSequence(Map<String, Object> seq) {
        String name = ((String) seq.get("SEQUENCE_NAME")).toUpperCase(Locale.ROOT);
        long increment = ((Number) seq.get("INCREMENT_BY")).longValue();
        java.math.BigDecimal lastNumber = (java.math.BigDecimal) seq.get("LAST_NUMBER");
        String drop = "DROP SEQUENCE IF EXISTS \"" + name + "\"";
        String create = "CREATE SEQUENCE IF NOT EXISTS \"" + name + "\" START WITH " + lastNumber.toPlainString() + " INCREMENT BY " + increment;
        String alter = "ALTER SEQUENCE \"" + name + "\" RESTART WITH " + lastNumber.toPlainString();
        h2.execute(drop);
        h2.execute(create);
        h2.execute(alter);
        log.info("Synced sequence {} startWith={}", name, lastNumber);
    }

    protected void copyTable(String table) {
        String src = oracleSchema + "." + table;
        String tgt = "\"" + table + "\"";
        log.info("Copying table {}", src);
        try (Connection oconn = oracleDs.getConnection();
             Statement s = oconn.createStatement();
             ResultSet rs = s.executeQuery("SELECT * FROM " + src + " WHERE 1=0")) {
            log.debug("Prepared metadata for {} using Oracle connection {}", src, oconn);
            createTargetTableFrom(rs.getMetaData(), tgt);
        } catch (SQLException e) {
            throw new RuntimeException("Prepare target table failed for " + src, e);
        }
        String selectSql = buildTableSelectSql(src, table);
        bulkInsertFromSelect(selectSql, tgt);
    }

    protected String buildTableSelectSql(String oracleQualifiedTable, String table) {
        return "SELECT * FROM " + oracleQualifiedTable;
    }

    private void copyView(String view) {
        String src = oracleSchema + "." + view;
        String viewName = "\"" + view + "\"";
        log.info("Creating H2 view {} from Oracle view {}", viewName, src);

        String oracleSql = fetchOracleViewDefinition(view);
        String translatedSql = translateViewSql(oracleSql);

        dropLegacyArtifacts(viewName, view);

        String createViewSql = "CREATE VIEW " + viewName + " AS " + translatedSql;
        h2.execute(createViewSql);
        log.info("Created H2 view {} using translated Oracle SQL", viewName);
    }

    private void dropLegacyArtifacts(String viewName, String view) {
        h2.execute("DROP VIEW IF EXISTS " + viewName);
        try {
            h2.execute("DROP TABLE IF EXISTS " + viewName);
        } catch (RuntimeException ex) {
            log.debug("Ignoring failure while dropping legacy table {}: {}", viewName, ex.getMessage());
        }
        String legacyMaterialized = "\"VW_" + view + "\"";
        try {
            h2.execute("DROP TABLE IF EXISTS " + legacyMaterialized);
        } catch (RuntimeException ex) {
            log.debug("Ignoring failure while dropping legacy materialized table {}: {}", legacyMaterialized, ex.getMessage());
        }
        String legacy = "\"MV\".\"" + view + "\"";
        try {
            h2.execute("DROP TABLE IF EXISTS " + legacy);
        } catch (RuntimeException ex) {
            log.debug("Ignoring failure while dropping legacy MV table {}: {}", legacy, ex.getMessage());
        }
    }

    private String fetchOracleViewDefinition(String view) {
        try (Connection conn = oracleDs.getConnection()) {
            String definition = fetchViewTextFromAllViews(conn, view);
            if (definition != null && !definition.isBlank()) {
                return definition;
            }
            return fetchViewTextFromMetadata(conn, view);
        } catch (SQLException e) {
            throw new RuntimeException("Failed to fetch Oracle view definition for " + view, e);
        }
    }

    private String fetchViewTextFromAllViews(Connection conn, String view) throws SQLException {
        String sql = "SELECT TEXT FROM all_views WHERE owner = ? AND view_name = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, oracleSchema);
            ps.setString(2, view);
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    return null;
                }
                return readLargeText(rs, 1);
            }
        }
    }

    private String fetchViewTextFromMetadata(Connection conn, String view) throws SQLException {
        log.debug("Falling back to DBMS_METADATA for Oracle view {}", view);
        try (Statement st = conn.createStatement()) {
            st.execute("BEGIN DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'SQLTERMINATOR',FALSE); END;");
        } catch (SQLException ex) {
            log.debug("Failed to configure DBMS_METADATA session transform: {}", ex.getMessage());
        }
        String sql = "SELECT dbms_metadata.get_ddl('VIEW', ?, ?) FROM dual";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, view);
            ps.setString(2, oracleSchema);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    String ddl = readLargeText(rs, 1);
                    if (ddl != null) {
                        String select = extractSelectFromDdl(ddl);
                        if (select != null && !select.isBlank()) {
                            return select;
                        }
                    }
                }
            }
        }
        throw new SQLException("Unable to retrieve definition for view " + view);
    }

    private String extractSelectFromDdl(String ddl) {
        if (ddl == null) {
            return null;
        }
        Matcher matcher = Pattern.compile("(?i)\\bAS\\b").matcher(ddl);
        if (matcher.find()) {
            return ddl.substring(matcher.end()).trim();
        }
        return null;
    }

    private String readLargeText(ResultSet rs, int index) throws SQLException {
        String text = rs.getString(index);
        if (text != null) {
            return text;
        }
        try (Reader reader = rs.getCharacterStream(index)) {
            if (reader == null) {
                return null;
            }
            StringBuilder sb = new StringBuilder();
            char[] buf = new char[4096];
            int len;
            while ((len = reader.read(buf)) != -1) {
                sb.append(buf, 0, len);
            }
            return sb.toString();
        } catch (IOException ex) {
            throw new SQLException("Failed to read Oracle text column", ex);
        }
    }

    private String translateViewSql(String oracleSql) {
        if (oracleSql == null) {
            throw new IllegalArgumentException("Oracle view SQL is null");
        }
        String stripped = stripSqlTerminator(stripComments(oracleSql)).trim();
        if (stripped.isEmpty()) {
            throw new IllegalArgumentException("Oracle view SQL is empty after cleaning");
        }
        String withoutSchema = removeOracleSchemaQualifiers(stripped);
        String cleaned = removeTrailingReadOnly(withoutSchema).trim();
        String uppercased = uppercaseUnquotedIdentifiers(cleaned);
        return replaceOracleSpecificFunctions(uppercased);
    }

    private String stripSqlTerminator(String sql) {
        String out = sql.trim();
        while (out.endsWith(";") || out.endsWith("/")) {
            out = out.substring(0, out.length() - 1).trim();
        }
        return out;
    }

    private String stripComments(String sql) {
        String noBlock = sql.replaceAll("(?is)/\\*.*?\\*/", " ");
        StringBuilder sb = new StringBuilder();
        try (Scanner scanner = new Scanner(noBlock)) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                int idx = line.indexOf("--");
                if (idx >= 0) {
                    line = line.substring(0, idx);
                }
                if (!line.isBlank()) {
                    if (sb.length() > 0) {
                        sb.append('\n');
                    }
                    sb.append(line);
                }
            }
        }
        return sb.toString();
    }

    private String removeOracleSchemaQualifiers(String sql) {
        if (oracleSchema == null || oracleSchema.isBlank()) {
            return sql;
        }
        String result = sql;
        String quotedSchema = Pattern.quote("\"" + oracleSchema + "\"");
        result = result.replaceAll("(?i)" + quotedSchema + "\\.", "");
        result = result.replaceAll("(?i)" + Pattern.quote(oracleSchema) + "\\.", "");
        return result;
    }

    private String removeTrailingReadOnly(String sql) {
        return sql.replaceAll("(?i)WITH\\s+READ\\s+ONLY", " ")
                .replaceAll("(?i)WITH\\s+CHECK\\s+OPTION", " ");
    }

    private String uppercaseUnquotedIdentifiers(String sql) {
        StringBuilder result = new StringBuilder(sql.length());
        int len = sql.length();
        int i = 0;
        while (i < len) {
            char c = sql.charAt(i);
            if (c == '\'') {
                result.append(c);
                i++;
                while (i < len) {
                    char current = sql.charAt(i);
                    result.append(current);
                    if (current == '\'') {
                        if (i + 1 < len && sql.charAt(i + 1) == '\'') {
                            result.append(sql.charAt(i + 1));
                            i += 2;
                            continue;
                        }
                        i++;
                        break;
                    }
                    i++;
                }
            } else if (c == '"') {
                result.append(c);
                i++;
                while (i < len) {
                    char current = sql.charAt(i);
                    result.append(current);
                    if (current == '"') {
                        if (i + 1 < len && sql.charAt(i + 1) == '"') {
                            result.append(sql.charAt(i + 1));
                            i += 2;
                            continue;
                        }
                        i++;
                        break;
                    }
                    i++;
                }
            } else if (Character.isLetter(c) || c == '_' || c == '$' || c == '#') {
                int start = i;
                i++;
                while (i < len) {
                    char current = sql.charAt(i);
                    if (Character.isLetterOrDigit(current) || current == '_' || current == '$' || current == '#') {
                        i++;
                    } else {
                        break;
                    }
                }
                result.append(sql.substring(start, i).toUpperCase(Locale.ROOT));
            } else {
                result.append(c);
                i++;
            }
        }
        return result.toString();
    }

    private String replaceOracleSpecificFunctions(String sql) {
        String replaced = replaceNvl2(sql);
        return moveJoinFiltersToWhere(replaced);
    }

    private String replaceNvl2(String sql) {
        StringBuilder result = new StringBuilder(sql.length());
        int len = sql.length();
        int i = 0;
        while (i < len) {
            if (matchesFunction(sql, i, "NVL2")) {
                int funcStart = i;
                i += 4;
                int afterName = skipWhitespace(sql, i);
                if (afterName >= len || sql.charAt(afterName) != '(') {
                    result.append(sql, funcStart, i);
                    continue;
                }
                int openParenIndex = afterName;
                int closeParenIndex = findMatchingParenthesis(sql, openParenIndex);
                if (closeParenIndex == -1) {
                    result.append(sql, funcStart, i);
                    continue;
                }
                String inner = sql.substring(openParenIndex + 1, closeParenIndex);
                List<String> args = splitTopLevelArguments(inner);
                if (args.size() != 3) {
                    result.append(sql, funcStart, closeParenIndex + 1);
                    i = closeParenIndex + 1;
                    continue;
                }
                String expr = replaceNvl2(args.get(0).trim());
                String notNullValue = replaceNvl2(args.get(1).trim());
                String nullValue = replaceNvl2(args.get(2).trim());
                result.append("CASE WHEN ")
                        .append(expr)
                        .append(" IS NOT NULL THEN ")
                        .append(notNullValue)
                        .append(" ELSE ")
                        .append(nullValue)
                        .append(" END");
                i = closeParenIndex + 1;
            } else {
                result.append(sql.charAt(i));
                i++;
            }
        }
        return result.toString();
    }

    private boolean matchesFunction(String sql, int offset, String name) {
        int len = sql.length();
        int nameLen = name.length();
        if (offset + nameLen > len) {
            return false;
        }
        for (int i = 0; i < nameLen; i++) {
            char c = sql.charAt(offset + i);
            if (Character.toUpperCase(c) != name.charAt(i)) {
                return false;
            }
        }
        if (offset > 0) {
            char prev = sql.charAt(offset - 1);
            if (Character.isLetterOrDigit(prev) || prev == '_' || prev == '$' || prev == '#') {
                return false;
            }
        }
        if (offset + nameLen < len) {
            char next = sql.charAt(offset + nameLen);
            if (Character.isLetterOrDigit(next) || next == '_' || next == '$' || next == '#') {
                return false;
            }
        }
        return true;
    }

    private int skipWhitespace(String sql, int index) {
        int len = sql.length();
        int i = index;
        while (i < len && Character.isWhitespace(sql.charAt(i))) {
            i++;
        }
        return i;
    }

    private int findMatchingParenthesis(String sql, int openIndex) {
        int len = sql.length();
        int depth = 0;
        boolean inSingle = false;
        boolean inDouble = false;
        for (int i = openIndex; i < len; i++) {
            char c = sql.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && sql.charAt(i + 1) == '\'') {
                    i++;
                } else {
                    inSingle = !inSingle;
                }
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && sql.charAt(i + 1) == '"') {
                    i++;
                } else {
                    inDouble = !inDouble;
                }
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (c == '(') {
                depth++;
            } else if (c == ')') {
                depth--;
                if (depth == 0) {
                    return i;
                }
                if (depth < 0) {
                    return -1;
                }
            }
        }
        return -1;
    }

    private List<String> splitTopLevelArguments(String input) {
        List<String> parts = new ArrayList<>();
        int len = input.length();
        int start = 0;
        int depth = 0;
        boolean inSingle = false;
        boolean inDouble = false;
        for (int i = 0; i < len; i++) {
            char c = input.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && input.charAt(i + 1) == '\'') {
                    i++;
                } else {
                    inSingle = !inSingle;
                }
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && input.charAt(i + 1) == '"') {
                    i++;
                } else {
                    inDouble = !inDouble;
                }
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (c == '(') {
                depth++;
            } else if (c == ')') {
                depth--;
            } else if (c == ',' && depth == 0) {
                parts.add(input.substring(start, i));
                start = i + 1;
            }
        }
        parts.add(input.substring(start));
        return parts;
    }

    private String moveJoinFiltersToWhere(String sql) {
        StringBuilder builder = new StringBuilder(sql);
        int offset = 0;
        while (offset < builder.length()) {
            int joinIndex = findKeywordOutsideQuotes(builder, offset, "JOIN");
            if (joinIndex == -1) {
                break;
            }
            int depth = calculateDepth(builder, joinIndex);
            int onIndex = findKeywordOutsideQuotes(builder, joinIndex, "ON");
            if (onIndex == -1) {
                offset = joinIndex + 4;
                continue;
            }
            int clauseStart = skipWhitespace(builder, onIndex + 2);
            int clauseEnd = findEndOfOnClause(builder, clauseStart);
            if (clauseEnd == -1) {
                offset = clauseStart;
                continue;
            }
            String onClause = builder.substring(clauseStart, clauseEnd).trim();
            if (onClause.isEmpty()) {
                offset = clauseEnd;
                continue;
            }
            List<String> conditions = splitTopLevelConditions(onClause);
            if (conditions.size() <= 1) {
                offset = clauseEnd;
                continue;
            }
            String primary = conditions.get(0).trim();
            List<String> extras = new ArrayList<>();
            for (int i = 1; i < conditions.size(); i++) {
                String cond = conditions.get(i).trim();
                if (!cond.isEmpty()) {
                    extras.add(cond);
                }
            }
            if (extras.isEmpty()) {
                offset = clauseEnd;
                continue;
            }
            builder.replace(clauseStart, clauseEnd, primary);
            int afterPrimary = clauseStart + primary.length();
            String extrasClause = String.join(" AND ", extras);
            int whereIndex = findKeywordAtDepth(builder, afterPrimary, depth, "WHERE");
            if (whereIndex != -1) {
                int whereEnd = findEndOfWhereClause(builder, whereIndex + 5, depth);
                String addition = " AND " + extrasClause;
                builder.insert(whereEnd, addition);
                offset = whereEnd + addition.length();
            } else {
                int boundary = findNextClauseBoundary(builder, afterPrimary, depth);
                String addition = " WHERE " + extrasClause;
                builder.insert(boundary, addition);
                offset = boundary + addition.length();
            }
        }
        return builder.toString();
    }

    private List<String> splitTopLevelConditions(String input) {
        List<String> parts = new ArrayList<>();
        int len = input.length();
        int start = 0;
        int depth = 0;
        boolean inSingle = false;
        boolean inDouble = false;
        int i = 0;
        while (i < len) {
            char c = input.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && input.charAt(i + 1) == '\'') {
                    i += 2;
                    continue;
                }
                inSingle = !inSingle;
                i++;
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && input.charAt(i + 1) == '"') {
                    i += 2;
                    continue;
                }
                inDouble = !inDouble;
                i++;
                continue;
            }
            if (inSingle || inDouble) {
                i++;
                continue;
            }
            if (c == '(') {
                depth++;
            } else if (c == ')') {
                depth = Math.max(0, depth - 1);
            } else if (depth == 0 && matchesKeyword(input, i, "AND") && !isPartOfBetween(input, start, i)) {
                int end = i;
                parts.add(input.substring(start, end));
                i += 3;
                while (i < len && Character.isWhitespace(input.charAt(i))) {
                    i++;
                }
                start = i;
                continue;
            }
            i++;
        }
        parts.add(input.substring(start));
        return parts;
    }

    private boolean isPartOfBetween(CharSequence sql, int sectionStart, int andOffset) {
        int i = andOffset - 1;
        while (i >= sectionStart && Character.isWhitespace(sql.charAt(i))) {
            i--;
        }
        int end = i + 1;
        while (i >= sectionStart && isIdentifierPart(sql.charAt(i))) {
            i--;
        }
        int start = i + 1;
        if (start < end) {
            String token = sql.subSequence(start, end).toString().toUpperCase(Locale.ROOT);
            if ("BETWEEN".equals(token)) {
                return true;
            }
        }
        return false;
    }

    private int findKeywordOutsideQuotes(CharSequence sql, int start, String keyword) {
        int len = sql.length();
        int klen = keyword.length();
        boolean inSingle = false;
        boolean inDouble = false;
        for (int i = start; i <= len - klen; i++) {
            char c = sql.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && sql.charAt(i + 1) == '\'') {
                    i++;
                    continue;
                }
                inSingle = !inSingle;
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && sql.charAt(i + 1) == '"') {
                    i++;
                    continue;
                }
                inDouble = !inDouble;
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (matchesKeyword(sql, i, keyword)) {
                return i;
            }
        }
        return -1;
    }

    private int calculateDepth(CharSequence sql, int index) {
        int depth = 0;
        boolean inSingle = false;
        boolean inDouble = false;
        for (int i = 0; i < index; i++) {
            char c = sql.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < index && sql.charAt(i + 1) == '\'') {
                    i++;
                    continue;
                }
                inSingle = !inSingle;
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < index && sql.charAt(i + 1) == '"') {
                    i++;
                    continue;
                }
                inDouble = !inDouble;
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (c == '(') {
                depth++;
            } else if (c == ')') {
                depth = Math.max(0, depth - 1);
            }
        }
        return depth;
    }

    private int findEndOfOnClause(CharSequence sql, int start) {
        int len = sql.length();
        int depth = 0;
        boolean inSingle = false;
        boolean inDouble = false;
        for (int i = start; i < len; i++) {
            char c = sql.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && sql.charAt(i + 1) == '\'') {
                    i++;
                    continue;
                }
                inSingle = !inSingle;
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && sql.charAt(i + 1) == '"') {
                    i++;
                    continue;
                }
                inDouble = !inDouble;
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (c == '(') {
                depth++;
            } else if (c == ')') {
                if (depth == 0) {
                    return i;
                }
                depth--;
            } else if (depth == 0) {
                if (matchesKeyword(sql, i, "WHERE")
                        || matchesKeyword(sql, i, "GROUP")
                        || matchesKeyword(sql, i, "HAVING")
                        || matchesKeyword(sql, i, "ORDER")
                        || matchesKeyword(sql, i, "CONNECT")
                        || matchesKeyword(sql, i, "START")
                        || matchesKeyword(sql, i, "UNION")
                        || matchesKeyword(sql, i, "INTERSECT")
                        || matchesKeyword(sql, i, "MINUS")
                        || matchesKeyword(sql, i, "FETCH")
                        || matchesKeyword(sql, i, "FOR")
                        || matchesKeyword(sql, i, "MODEL")
                        || matchesKeyword(sql, i, "WINDOW")) {
                    return i;
                }
            }
        }
        return len;
    }

    private int findKeywordAtDepth(CharSequence sql, int start, int targetDepth, String keyword) {
        int len = sql.length();
        boolean inSingle = false;
        boolean inDouble = false;
        int depth = calculateDepth(sql, start);
        for (int i = start; i < len; i++) {
            char c = sql.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && sql.charAt(i + 1) == '\'') {
                    i++;
                    continue;
                }
                inSingle = !inSingle;
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && sql.charAt(i + 1) == '"') {
                    i++;
                    continue;
                }
                inDouble = !inDouble;
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (c == '(') {
                depth++;
                continue;
            }
            if (c == ')') {
                depth = Math.max(0, depth - 1);
                if (depth < targetDepth) {
                    return -1;
                }
                continue;
            }
            if (depth == targetDepth && matchesKeyword(sql, i, keyword)) {
                return i;
            }
        }
        return -1;
    }

    private int findEndOfWhereClause(CharSequence sql, int start, int targetDepth) {
        int len = sql.length();
        boolean inSingle = false;
        boolean inDouble = false;
        int depth = calculateDepth(sql, start);
        for (int i = start; i < len; i++) {
            char c = sql.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && sql.charAt(i + 1) == '\'') {
                    i++;
                    continue;
                }
                inSingle = !inSingle;
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && sql.charAt(i + 1) == '"') {
                    i++;
                    continue;
                }
                inDouble = !inDouble;
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (c == '(') {
                depth++;
                continue;
            }
            if (c == ')') {
                depth = Math.max(0, depth - 1);
                if (depth < targetDepth) {
                    return i;
                }
                continue;
            }
            if (depth == targetDepth && (matchesKeyword(sql, i, "GROUP")
                    || matchesKeyword(sql, i, "HAVING")
                    || matchesKeyword(sql, i, "ORDER")
                    || matchesKeyword(sql, i, "UNION")
                    || matchesKeyword(sql, i, "INTERSECT")
                    || matchesKeyword(sql, i, "MINUS")
                    || matchesKeyword(sql, i, "CONNECT")
                    || matchesKeyword(sql, i, "START")
                    || matchesKeyword(sql, i, "FETCH")
                    || matchesKeyword(sql, i, "FOR")
                    || matchesKeyword(sql, i, "MODEL")
                    || matchesKeyword(sql, i, "WINDOW"))) {
                return i;
            }
        }
        return len;
    }

    private int findNextClauseBoundary(CharSequence sql, int start, int targetDepth) {
        int len = sql.length();
        boolean inSingle = false;
        boolean inDouble = false;
        int depth = calculateDepth(sql, start);
        for (int i = start; i < len; i++) {
            char c = sql.charAt(i);
            if (c == '\'' && !inDouble) {
                if (inSingle && i + 1 < len && sql.charAt(i + 1) == '\'') {
                    i++;
                    continue;
                }
                inSingle = !inSingle;
                continue;
            }
            if (c == '"' && !inSingle) {
                if (inDouble && i + 1 < len && sql.charAt(i + 1) == '"') {
                    i++;
                    continue;
                }
                inDouble = !inDouble;
                continue;
            }
            if (inSingle || inDouble) {
                continue;
            }
            if (c == '(') {
                depth++;
                continue;
            }
            if (c == ')') {
                depth = Math.max(0, depth - 1);
                if (depth < targetDepth) {
                    return i;
                }
                continue;
            }
            if (depth == targetDepth && (matchesKeyword(sql, i, "WHERE")
                    || matchesKeyword(sql, i, "GROUP")
                    || matchesKeyword(sql, i, "HAVING")
                    || matchesKeyword(sql, i, "ORDER")
                    || matchesKeyword(sql, i, "UNION")
                    || matchesKeyword(sql, i, "INTERSECT")
                    || matchesKeyword(sql, i, "MINUS")
                    || matchesKeyword(sql, i, "CONNECT")
                    || matchesKeyword(sql, i, "START")
                    || matchesKeyword(sql, i, "FETCH")
                    || matchesKeyword(sql, i, "FOR")
                    || matchesKeyword(sql, i, "MODEL")
                    || matchesKeyword(sql, i, "WINDOW"))) {
                return i;
            }
        }
        return len;
    }

    private boolean matchesKeyword(CharSequence sql, int offset, String keyword) {
        int len = sql.length();
        int klen = keyword.length();
        if (offset < 0 || offset + klen > len) {
            return false;
        }
        for (int i = 0; i < klen; i++) {
            char c = sql.charAt(offset + i);
            if (Character.toUpperCase(c) != keyword.charAt(i)) {
                return false;
            }
        }
        if (offset > 0) {
            char prev = sql.charAt(offset - 1);
            if (isIdentifierPart(prev)) {
                return false;
            }
        }
        if (offset + klen < len) {
            char next = sql.charAt(offset + klen);
            if (isIdentifierPart(next)) {
                return false;
            }
        }
        return true;
    }

    private int skipWhitespace(CharSequence sql, int index) {
        int len = sql.length();
        int i = index;
        while (i < len && Character.isWhitespace(sql.charAt(i))) {
            i++;
        }
        return i;
    }

    private boolean isIdentifierPart(char c) {
        return Character.isLetterOrDigit(c) || c == '_' || c == '$' || c == '#';
    }

    private void createTargetTableFrom(ResultSetMetaData md, String target) throws SQLException {
        String drop = "DROP TABLE IF EXISTS " + target;
        h2.execute(drop);
        StringBuilder ddl = new StringBuilder("CREATE TABLE ").append(target).append(" (");
        for (int i = 1; i <= md.getColumnCount(); i++) {
            if (i > 1) ddl.append(", ");
            String name = md.getColumnName(i);
            int type = md.getColumnType(i);
            int precision = md.getPrecision(i);
            int scale = md.getScale(i);
            ddl.append("\"").append(name).append("\" ").append(mapType(type, precision, scale));
        }
        ddl.append(")");
        h2.execute(ddl.toString());
    }

    private String mapType(int jdbcType, int precision, int scale) {
        switch (jdbcType) {
            case Types.INTEGER:
            case Types.SMALLINT:
            case Types.TINYINT:
                return "INTEGER";
            case Types.BIGINT:
                return "BIGINT";
            case Types.DECIMAL:
            case Types.NUMERIC:
                if (scale == 0 && precision > 0) {
                    if (precision <= 9) return "INTEGER";
                    if (precision <= 18) return "BIGINT";
                }
                int p = Math.min(precision == 0 ? 38 : precision, 38);
                int s;
                if (scale < 0) {
                    s = Math.min(p, 12);
                } else {
                    s = Math.min(scale, 12);
                }
                if (s < 0 || s > p) {
                    s = Math.min(p, 12);
                }
                return "DECIMAL(" + p + "," + s + ")";
            case Types.FLOAT:
            case Types.REAL:
            case Types.DOUBLE:
                return "DOUBLE";
            case Types.DATE:
            case Types.TIME:
            case Types.TIMESTAMP:
            case Types.TIMESTAMP_WITH_TIMEZONE:
                return "TIMESTAMP";
            case Types.BOOLEAN:
            case Types.BIT:
                return "BOOLEAN";
            case Types.BLOB:
            case Types.BINARY:
            case Types.VARBINARY:
            case Types.LONGVARBINARY:
                return "BLOB";
            case Types.CLOB:
            case Types.NCLOB:
            case Types.LONGVARCHAR:
            case Types.LONGNVARCHAR:
                return "CLOB";
            case Types.NCHAR:
            case Types.NVARCHAR:
            case Types.CHAR:
            case Types.VARCHAR:
            default:
                int len = precision > 0 ? precision : 255;
                len = Math.min(len, 10000);
                return "VARCHAR(" + len + ")";
        }
    }

    private void bulkInsertFromSelect(String selectSql, String target) {
        String countSql = "SELECT COUNT(1) FROM (" + selectSql + ") t";
        long total = 0;
        try (Connection oconn = oracleDs.getConnection()) {
            try (Statement st = oconn.createStatement();
                 ResultSet crs = st.executeQuery(countSql)) {
                if (crs.next()) total = crs.getLong(1);
            } catch (SQLException e) {
                log.warn("Count failed (non-fatal) for {}: {}", selectSql, e.getMessage());
            }

            try (PreparedStatement src = oconn.prepareStatement(selectSql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
                log.debug("Streaming data for target {} using Oracle connection {}", target, oconn);
                src.setFetchSize(Math.max(batchSize, 100));
                try (ResultSet rs = src.executeQuery()) {
                    ResultSetMetaData md = rs.getMetaData();
                    int cols = md.getColumnCount();
                    StringBuilder sb = new StringBuilder("INSERT INTO ").append(target).append(" (");
                    for (int i = 1; i <= cols; i++) {
                        if (i > 1) sb.append(",");
                        sb.append("\"").append(md.getColumnName(i)).append("\"");
                    }
                    sb.append(") VALUES (");
                    for (int i = 1; i <= cols; i++) {
                        if (i > 1) sb.append(",");
                        sb.append("?");
                    }
                    sb.append(")");
                    String insertSql = sb.toString();

                    try (Connection h2conn = Objects.requireNonNull(h2.getDataSource()).getConnection()) {
                        h2conn.setAutoCommit(false);
                        try (PreparedStatement ins = h2conn.prepareStatement(insertSql)) {
                            long n = 0;
                            while (rs.next()) {
                                for (int i = 1; i <= cols; i++) {
                                    Object v = readColumnValue(rs, md, i);
                                    ins.setObject(i, v);
                                }
                                ins.addBatch();
                                n++;
                                if (n % batchSize == 0) {
                                    ins.executeBatch();
                                    h2conn.commit();
                                    if (total > 0) {
                                        log.info("Inserted {} / {} into {}", n, total, target);
                                    } else if (n % (batchSize * 10) == 0) {
                                        log.info("Inserted {} rows into {}", n, target);
                                    }
                                }
                            }
                            ins.executeBatch();
                            h2conn.commit();
                            log.info("Inserted {} rows into {}", n, target);
                        } catch (SQLException ex) {
                            h2conn.rollback();
                            throw ex;
                        } finally {
                            h2conn.setAutoCommit(true);
                        }
                    }
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException("Bulk insert failed for target " + target, e);
        }
    }

    private Object readColumnValue(ResultSet rs, ResultSetMetaData md, int index) throws SQLException {
        int jdbcType = md.getColumnType(index);

        if (isBinaryType(jdbcType)) {
            byte[] data = rs.getBytes(index);
            return rs.wasNull() ? null : data;
        }

        if (isClobType(jdbcType)) {
            String text = rs.getString(index);
            return rs.wasNull() ? null : text;
        }

        if (isTemporalType(jdbcType)) {
            try {
                Timestamp ts = rs.getTimestamp(index);
                if (ts != null || rs.wasNull()) {
                    return ts;
                }
            } catch (SQLException ex) {
                log.debug("Oracle timestamp conversion failed for column {} using getTimestamp: {}", index, ex.getMessage());
            }
        }

        Object value = rs.getObject(index);

        if (value instanceof Blob) {
            return blobToBytes((Blob) value);
        }
        if (value instanceof Clob) {
            return clobToString((Clob) value);
        }

        if (isTemporalType(jdbcType)) {
            return toTimestamp(value);
        }
        return maybeConvertTemporal(value);
    }

    private boolean isTemporalType(int jdbcType) {
        return jdbcType == Types.DATE
                || jdbcType == Types.TIME
                || jdbcType == Types.TIMESTAMP
                || jdbcType == Types.TIMESTAMP_WITH_TIMEZONE
                || jdbcType == Types.TIME_WITH_TIMEZONE;
    }

    private boolean isBinaryType(int jdbcType) {
        return jdbcType == Types.BLOB
                || jdbcType == Types.BINARY
                || jdbcType == Types.VARBINARY
                || jdbcType == Types.LONGVARBINARY;
    }

    private boolean isClobType(int jdbcType) {
        return jdbcType == Types.CLOB
                || jdbcType == Types.NCLOB
                || jdbcType == Types.LONGVARCHAR
                || jdbcType == Types.LONGNVARCHAR;
    }

    private Object maybeConvertTemporal(Object value) throws SQLException {
        if (value == null) return null;
        if (value instanceof Timestamp) return value;
        if (value instanceof java.sql.Date || value instanceof java.sql.Time || value instanceof java.util.Date) {
            return toTimestamp(value);
        }
        if (value instanceof LocalDateTime || value instanceof LocalDate
                || value instanceof Instant || value instanceof OffsetDateTime
                || value instanceof ZonedDateTime) {
            return toTimestamp(value);
        }
        String className = value.getClass().getName();
        if (className.startsWith("oracle.sql.")) {
            return toTimestamp(value);
        }
        return value;
    }

    private byte[] blobToBytes(Blob blob) throws SQLException {
        if (blob == null) {
            return null;
        }
        try {
            long length = blob.length();
            if (length > Integer.MAX_VALUE) {
                throw new SQLException("BLOB length exceeds supported size: " + length);
            }
            return blob.getBytes(1, (int) length);
        } finally {
            free(blob);
        }
    }

    private String clobToString(Clob clob) throws SQLException {
        if (clob == null) {
            return null;
        }
        try {
            long length = clob.length();
            if (length > Integer.MAX_VALUE) {
                throw new SQLException("CLOB length exceeds supported size: " + length);
            }
            return clob.getSubString(1, (int) length);
        } finally {
            free(clob);
        }
    }

    private void free(Blob blob) {
        if (blob == null) {
            return;
        }
        try {
            blob.free();
        } catch (AbstractMethodError | SQLException ignored) {
            // Some drivers (or older JDBC versions) do not support free(); ignore such cases.
        }
    }

    private void free(Clob clob) {
        if (clob == null) {
            return;
        }
        try {
            clob.free();
        } catch (AbstractMethodError | SQLException ignored) {
            // Ignore drivers that do not implement free()
        }
    }

    private Object toTimestamp(Object value) throws SQLException {
        if (value == null) return null;
        if (value instanceof Timestamp) return value;
        if (value instanceof java.sql.Date) {
            return new Timestamp(((java.sql.Date) value).getTime());
        }
        if (value instanceof java.sql.Time) {
            return new Timestamp(((java.sql.Time) value).getTime());
        }
        if (value instanceof java.util.Date) {
            return new Timestamp(((java.util.Date) value).getTime());
        }
        if (value instanceof LocalDateTime) {
            return Timestamp.valueOf((LocalDateTime) value);
        }
        if (value instanceof LocalDate) {
            return Timestamp.valueOf(((LocalDate) value).atStartOfDay());
        }
        if (value instanceof Instant) {
            return Timestamp.from((Instant) value);
        }
        if (value instanceof OffsetDateTime) {
            return Timestamp.valueOf(((OffsetDateTime) value).toLocalDateTime());
        }
        if (value instanceof ZonedDateTime) {
            return Timestamp.valueOf(((ZonedDateTime) value).toLocalDateTime());
        }

        String className = value.getClass().getName();
        if (className.startsWith("oracle.sql.")) {
            try {
                Method method = value.getClass().getMethod("timestampValue");
                Object ts = method.invoke(value);
                if (ts instanceof Timestamp) {
                    return ts;
                }
            } catch (NoSuchMethodException ignored) {
                // fall through and try other conversion methods
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new SQLException("Failed to convert Oracle temporal value of type " + className, e);
            }

            try {
                Method method = value.getClass().getMethod("dateValue");
                Object date = method.invoke(value);
                if (date instanceof java.sql.Date) {
                    return new Timestamp(((java.sql.Date) date).getTime());
                }
            } catch (NoSuchMethodException ignored) {
                // fall through
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new SQLException("Failed to convert Oracle temporal value of type " + className, e);
            }

            try {
                Method method = value.getClass().getMethod("timeValue");
                Object time = method.invoke(value);
                if (time instanceof java.sql.Time) {
                    return new Timestamp(((java.sql.Time) time).getTime());
                }
            } catch (NoSuchMethodException ignored) {
                // fall through
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new SQLException("Failed to convert Oracle temporal value of type " + className, e);
            }
        }

        return value;
    }
}
